name: 'Helm Deploy'
description: 'Deploy Helm charts with prerequisites, validation, and rollback support'

inputs:
  # ------------------------------------------------------------------------------
  # Action Mode
  # ------------------------------------------------------------------------------
  action:
    description: 'Action to perform: install, upgrade, uninstall, diff, template'
    required: false
    default: 'upgrade'

  # ------------------------------------------------------------------------------
  # Cluster Configuration
  # ------------------------------------------------------------------------------
  kubeconfig:
    description: 'Base64 encoded kubeconfig'
    required: true
  
  cluster-name:
    description: 'Cluster name for logging purposes'
    required: false
    default: 'default'

  # ------------------------------------------------------------------------------
  # Prerequisites Chart
  # ------------------------------------------------------------------------------
  prereq-enabled:
    description: 'Enable prerequisites chart deployment'
    required: false
    default: 'false'
  
  prereq-repo-name:
    description: 'Prerequisites Helm repo name'
    required: false
    default: 'platform'
  
  prereq-repo-url:
    description: 'Prerequisites Helm repo URL'
    required: false
    default: ''
  
  prereq-chart:
    description: 'Prerequisites chart name (repo/chart or path)'
    required: false
    default: 'platform/platform-prereqs'
  
  prereq-release-name:
    description: 'Prerequisites release name'
    required: false
    default: ''
  
  prereq-version:
    description: 'Prerequisites chart version'
    required: false
    default: ''
  
  prereq-values-files:
    description: 'Comma-separated list of prerequisites values files'
    required: false
    default: ''
  
  prereq-set-values:
    description: 'Prerequisites --set values (comma-separated key=value)'
    required: false
    default: ''

  # ------------------------------------------------------------------------------
  # Application Chart
  # ------------------------------------------------------------------------------
  release-name:
    description: 'Helm release name'
    required: true
  
  namespace:
    description: 'Kubernetes namespace'
    required: true
  
  chart:
    description: 'Chart path or repo/chart'
    required: true
  
  chart-version:
    description: 'Chart version (for remote charts)'
    required: false
    default: ''
  
  repo-name:
    description: 'Helm repo name (if using remote chart)'
    required: false
    default: ''
  
  repo-url:
    description: 'Helm repo URL (if using remote chart)'
    required: false
    default: ''
  
  values-files:
    description: 'Comma-separated list of values files'
    required: false
    default: ''
  
  set-values:
    description: '--set values (comma-separated key=value)'
    required: false
    default: ''
  
  set-string-values:
    description: '--set-string values (comma-separated key=value)'
    required: false
    default: ''

  # ------------------------------------------------------------------------------
  # Deployment Options
  # ------------------------------------------------------------------------------
  create-namespace:
    description: 'Create namespace if it does not exist'
    required: false
    default: 'true'
  
  atomic:
    description: 'Rollback on failure'
    required: false
    default: 'true'
  
  wait:
    description: 'Wait for resources to be ready'
    required: false
    default: 'true'
  
  timeout:
    description: 'Timeout for Helm operations'
    required: false
    default: '10m'
  
  force:
    description: 'Force resource updates'
    required: false
    default: 'false'
  
  cleanup-on-fail:
    description: 'Cleanup new resources on failure'
    required: false
    default: 'true'
  
  history-max:
    description: 'Max number of releases to keep'
    required: false
    default: '5'
  
  debug:
    description: 'Enable debug mode'
    required: false
    default: 'false'

  # ------------------------------------------------------------------------------
  # Validation & Health Checks
  # ------------------------------------------------------------------------------
  dry-run:
    description: 'Perform dry-run only'
    required: false
    default: 'false'
  
  verify-install:
    description: 'Verify deployment health after install'
    required: false
    default: 'true'
  
  verify-timeout:
    description: 'Timeout for verification checks'
    required: false
    default: '5m'
  
  required-resources:
    description: 'Comma-separated resources to verify (e.g., deployment/app,secret/creds)'
    required: false
    default: ''

  # ------------------------------------------------------------------------------
  # Notifications
  # ------------------------------------------------------------------------------
  slack-webhook:
    description: 'Slack webhook URL for notifications'
    required: false
    default: ''
  
  slack-channel:
    description: 'Slack channel override'
    required: false
    default: ''

outputs:
  release-name:
    description: 'Deployed release name'
    value: ${{ steps.deploy.outputs.release-name }}
  
  release-namespace:
    description: 'Deployed release namespace'
    value: ${{ steps.deploy.outputs.release-namespace }}
  
  release-revision:
    description: 'Release revision number'
    value: ${{ steps.deploy.outputs.release-revision }}
  
  release-status:
    description: 'Release status'
    value: ${{ steps.deploy.outputs.release-status }}
  
  prereq-status:
    description: 'Prerequisites release status'
    value: ${{ steps.prereqs.outputs.status }}

runs:
  using: 'composite'
  steps:
    # --------------------------------------------------------------------------
    # Setup
    # --------------------------------------------------------------------------
    - name: Set up Helm
      uses: azure/setup-helm@v4
      with:
        version: 'v3.14.0'

    - name: Set up kubectl
      uses: azure/setup-kubectl@v4

    - name: Configure kubeconfig
      shell: bash
      run: |
        mkdir -p ~/.kube
        echo "${{ inputs.kubeconfig }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: Verify cluster connection
      shell: bash
      run: |
        echo "üîå Connecting to cluster: ${{ inputs.cluster-name }}"
        if ! kubectl cluster-info &>/dev/null; then
          echo "‚ùå Failed to connect to cluster"
          exit 1
        fi
        echo "‚úÖ Cluster connection verified"
        kubectl get nodes -o wide || true

    # --------------------------------------------------------------------------
    # Add Helm Repos
    # --------------------------------------------------------------------------
    - name: Add prerequisites Helm repo
      if: inputs.prereq-enabled == 'true' && inputs.prereq-repo-url != ''
      shell: bash
      run: |
        echo "üì¶ Adding prerequisites Helm repo: ${{ inputs.prereq-repo-name }}"
        helm repo add ${{ inputs.prereq-repo-name }} ${{ inputs.prereq-repo-url }}
        helm repo update

    - name: Add application Helm repo
      if: inputs.repo-url != ''
      shell: bash
      run: |
        echo "üì¶ Adding application Helm repo: ${{ inputs.repo-name }}"
        helm repo add ${{ inputs.repo-name }} ${{ inputs.repo-url }}
        helm repo update

    # --------------------------------------------------------------------------
    # Pre-flight Checks
    # --------------------------------------------------------------------------
    - name: Pre-flight checks
      shell: bash
      run: |
        echo "üîç Running pre-flight checks..."
        
        # Check if namespace exists (for uninstall)
        if [[ "${{ inputs.action }}" == "uninstall" ]]; then
          if ! kubectl get namespace ${{ inputs.namespace }} &>/dev/null; then
            echo "‚ö†Ô∏è Namespace ${{ inputs.namespace }} does not exist"
          fi
        fi
        
        # Check existing release
        echo "üìã Existing releases in namespace:"
        helm list -n ${{ inputs.namespace }} 2>/dev/null || echo "No releases found"
        
        # Validate values files exist
        if [[ -n "${{ inputs.values-files }}" ]]; then
          IFS=',' read -ra FILES <<< "${{ inputs.values-files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Values file not found: $file"
              exit 1
            fi
            echo "‚úÖ Values file exists: $file"
          done
        fi
        
        echo "‚úÖ Pre-flight checks passed"

    # --------------------------------------------------------------------------
    # Prerequisites Deployment
    # --------------------------------------------------------------------------
    - name: Deploy prerequisites
      id: prereqs
      if: inputs.prereq-enabled == 'true' && inputs.action != 'uninstall'
      shell: bash
      run: |
        echo "üöÄ Deploying prerequisites..."
        
        PREREQ_RELEASE="${{ inputs.prereq-release-name }}"
        if [[ -z "$PREREQ_RELEASE" ]]; then
          PREREQ_RELEASE="${{ inputs.release-name }}-prereqs"
        fi
        
        # Build values files args
        VALUES_ARGS=""
        if [[ -n "${{ inputs.prereq-values-files }}" ]]; then
          IFS=',' read -ra FILES <<< "${{ inputs.prereq-values-files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)
            VALUES_ARGS="$VALUES_ARGS -f $file"
          done
        fi
        
        # Build set values args
        SET_ARGS=""
        if [[ -n "${{ inputs.prereq-set-values }}" ]]; then
          IFS=',' read -ra SETS <<< "${{ inputs.prereq-set-values }}"
          for item in "${SETS[@]}"; do
            item=$(echo "$item" | xargs)
            SET_ARGS="$SET_ARGS --set $item"
          done
        fi
        
        # Version arg
        VERSION_ARG=""
        if [[ -n "${{ inputs.prereq-version }}" ]]; then
          VERSION_ARG="--version ${{ inputs.prereq-version }}"
        fi
        
        # Debug arg
        DEBUG_ARG=""
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          DEBUG_ARG="--debug"
        fi
        
        # Dry run arg
        DRY_RUN_ARG=""
        if [[ "${{ inputs.dry-run }}" == "true" ]]; then
          DRY_RUN_ARG="--dry-run"
        fi
        
        # Run helm upgrade
        helm upgrade --install "$PREREQ_RELEASE" \
          ${{ inputs.prereq-chart }} \
          --namespace ${{ inputs.namespace }} \
          --create-namespace \
          --wait \
          --timeout ${{ inputs.timeout }} \
          --history-max ${{ inputs.history-max }} \
          $VERSION_ARG \
          $VALUES_ARGS \
          $SET_ARGS \
          $DEBUG_ARG \
          $DRY_RUN_ARG
        
        echo "status=success" >> $GITHUB_OUTPUT
        echo "‚úÖ Prerequisites deployed successfully"

    - name: Verify prerequisites
      if: inputs.prereq-enabled == 'true' && inputs.action != 'uninstall' && inputs.dry-run != 'true'
      shell: bash
      run: |
        echo "üîç Verifying prerequisites..."
        
        PREREQ_RELEASE="${{ inputs.prereq-release-name }}"
        if [[ -z "$PREREQ_RELEASE" ]]; then
          PREREQ_RELEASE="${{ inputs.release-name }}-prereqs"
        fi
        
        # Check release status
        STATUS=$(helm status "$PREREQ_RELEASE" -n ${{ inputs.namespace }} -o json | jq -r '.info.status')
        echo "Prerequisites release status: $STATUS"
        
        if [[ "$STATUS" != "deployed" ]]; then
          echo "‚ùå Prerequisites not in deployed state"
          exit 1
        fi
        
        # Wait for SecretProviderClass if it exists
        if kubectl get secretproviderclass -n ${{ inputs.namespace }} &>/dev/null; then
          echo "üìã SecretProviderClass resources:"
          kubectl get secretproviderclass -n ${{ inputs.namespace }}
        fi
        
        # Wait for ServiceAccount
        if kubectl get serviceaccount -n ${{ inputs.namespace }} &>/dev/null; then
          echo "üìã ServiceAccount resources:"
          kubectl get serviceaccount -n ${{ inputs.namespace }}
        fi
        
        # Wait for PVC to be bound if it exists
        if kubectl get pvc -n ${{ inputs.namespace }} &>/dev/null; then
          echo "üìã PVC resources:"
          kubectl get pvc -n ${{ inputs.namespace }}
          
          # Wait for PVC to be bound
          PVCS=$(kubectl get pvc -n ${{ inputs.namespace }} -o jsonpath='{.items[*].metadata.name}')
          for pvc in $PVCS; do
            echo "‚è≥ Waiting for PVC $pvc to be bound..."
            kubectl wait --for=jsonpath='{.status.phase}'=Bound pvc/$pvc -n ${{ inputs.namespace }} --timeout=2m || true
          done
        fi
        
        echo "‚úÖ Prerequisites verification complete"

    # --------------------------------------------------------------------------
    # Diff (for upgrade visibility)
    # --------------------------------------------------------------------------
    - name: Show diff
      if: inputs.action == 'diff' || (inputs.action == 'upgrade' && inputs.dry-run != 'true')
      shell: bash
      continue-on-error: true
      run: |
        echo "üìä Generating diff..."
        
        # Install helm-diff plugin if not present
        if ! helm plugin list | grep -q diff; then
          helm plugin install https://github.com/databus23/helm-diff || true
        fi
        
        # Build values files args
        VALUES_ARGS=""
        if [[ -n "${{ inputs.values-files }}" ]]; then
          IFS=',' read -ra FILES <<< "${{ inputs.values-files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)
            VALUES_ARGS="$VALUES_ARGS -f $file"
          done
        fi
        
        # Build set values args
        SET_ARGS=""
        if [[ -n "${{ inputs.set-values }}" ]]; then
          IFS=',' read -ra SETS <<< "${{ inputs.set-values }}"
          for item in "${SETS[@]}"; do
            item=$(echo "$item" | xargs)
            SET_ARGS="$SET_ARGS --set $item"
          done
        fi
        
        # Version arg
        VERSION_ARG=""
        if [[ -n "${{ inputs.chart-version }}" ]]; then
          VERSION_ARG="--version ${{ inputs.chart-version }}"
        fi
        
        helm diff upgrade ${{ inputs.release-name }} \
          ${{ inputs.chart }} \
          --namespace ${{ inputs.namespace }} \
          --allow-unreleased \
          $VERSION_ARG \
          $VALUES_ARGS \
          $SET_ARGS || echo "No existing release to diff against"

    # --------------------------------------------------------------------------
    # Template (dry-run output)
    # --------------------------------------------------------------------------
    - name: Template output
      if: inputs.action == 'template'
      shell: bash
      run: |
        echo "üìÑ Generating template output..."
        
        # Build values files args
        VALUES_ARGS=""
        if [[ -n "${{ inputs.values-files }}" ]]; then
          IFS=',' read -ra FILES <<< "${{ inputs.values-files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)
            VALUES_ARGS="$VALUES_ARGS -f $file"
          done
        fi
        
        # Build set values args
        SET_ARGS=""
        if [[ -n "${{ inputs.set-values }}" ]]; then
          IFS=',' read -ra SETS <<< "${{ inputs.set-values }}"
          for item in "${SETS[@]}"; do
            item=$(echo "$item" | xargs)
            SET_ARGS="$SET_ARGS --set $item"
          done
        fi
        
        # Version arg
        VERSION_ARG=""
        if [[ -n "${{ inputs.chart-version }}" ]]; then
          VERSION_ARG="--version ${{ inputs.chart-version }}"
        fi
        
        helm template ${{ inputs.release-name }} \
          ${{ inputs.chart }} \
          --namespace ${{ inputs.namespace }} \
          $VERSION_ARG \
          $VALUES_ARGS \
          $SET_ARGS

    # --------------------------------------------------------------------------
    # Deploy Application
    # --------------------------------------------------------------------------
    - name: Deploy application
      id: deploy
      if: inputs.action == 'install' || inputs.action == 'upgrade'
      shell: bash
      run: |
        echo "üöÄ Deploying ${{ inputs.release-name }} to ${{ inputs.namespace }}..."
        
        # Build values files args
        VALUES_ARGS=""
        if [[ -n "${{ inputs.values-files }}" ]]; then
          IFS=',' read -ra FILES <<< "${{ inputs.values-files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)
            VALUES_ARGS="$VALUES_ARGS -f $file"
          done
        fi
        
        # Build set values args
        SET_ARGS=""
        if [[ -n "${{ inputs.set-values }}" ]]; then
          IFS=',' read -ra SETS <<< "${{ inputs.set-values }}"
          for item in "${SETS[@]}"; do
            item=$(echo "$item" | xargs)
            SET_ARGS="$SET_ARGS --set $item"
          done
        fi
        
        # Build set-string values args
        SET_STRING_ARGS=""
        if [[ -n "${{ inputs.set-string-values }}" ]]; then
          IFS=',' read -ra SETS <<< "${{ inputs.set-string-values }}"
          for item in "${SETS[@]}"; do
            item=$(echo "$item" | xargs)
            SET_STRING_ARGS="$SET_STRING_ARGS --set-string $item"
          done
        fi
        
        # Version arg
        VERSION_ARG=""
        if [[ -n "${{ inputs.chart-version }}" ]]; then
          VERSION_ARG="--version ${{ inputs.chart-version }}"
        fi
        
        # Optional flags
        CREATE_NS_ARG=""
        if [[ "${{ inputs.create-namespace }}" == "true" ]]; then
          CREATE_NS_ARG="--create-namespace"
        fi
        
        ATOMIC_ARG=""
        if [[ "${{ inputs.atomic }}" == "true" ]]; then
          ATOMIC_ARG="--atomic"
        fi
        
        WAIT_ARG=""
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          WAIT_ARG="--wait"
        fi
        
        FORCE_ARG=""
        if [[ "${{ inputs.force }}" == "true" ]]; then
          FORCE_ARG="--force"
        fi
        
        CLEANUP_ARG=""
        if [[ "${{ inputs.cleanup-on-fail }}" == "true" ]]; then
          CLEANUP_ARG="--cleanup-on-fail"
        fi
        
        DEBUG_ARG=""
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          DEBUG_ARG="--debug"
        fi
        
        DRY_RUN_ARG=""
        if [[ "${{ inputs.dry-run }}" == "true" ]]; then
          DRY_RUN_ARG="--dry-run"
        fi
        
        # Run helm upgrade --install
        helm upgrade --install ${{ inputs.release-name }} \
          ${{ inputs.chart }} \
          --namespace ${{ inputs.namespace }} \
          --timeout ${{ inputs.timeout }} \
          --history-max ${{ inputs.history-max }} \
          $CREATE_NS_ARG \
          $ATOMIC_ARG \
          $WAIT_ARG \
          $FORCE_ARG \
          $CLEANUP_ARG \
          $VERSION_ARG \
          $VALUES_ARGS \
          $SET_ARGS \
          $SET_STRING_ARGS \
          $DEBUG_ARG \
          $DRY_RUN_ARG
        
        # Set outputs
        if [[ "${{ inputs.dry-run }}" != "true" ]]; then
          REVISION=$(helm history ${{ inputs.release-name }} -n ${{ inputs.namespace }} --max 1 -o json | jq -r '.[0].revision')
          STATUS=$(helm status ${{ inputs.release-name }} -n ${{ inputs.namespace }} -o json | jq -r '.info.status')
          
          echo "release-name=${{ inputs.release-name }}" >> $GITHUB_OUTPUT
          echo "release-namespace=${{ inputs.namespace }}" >> $GITHUB_OUTPUT
          echo "release-revision=$REVISION" >> $GITHUB_OUTPUT
          echo "release-status=$STATUS" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Deployment complete"
          echo "   Release: ${{ inputs.release-name }}"
          echo "   Namespace: ${{ inputs.namespace }}"
          echo "   Revision: $REVISION"
          echo "   Status: $STATUS"
        fi

    # --------------------------------------------------------------------------
    # Uninstall
    # --------------------------------------------------------------------------
    - name: Uninstall application
      if: inputs.action == 'uninstall'
      shell: bash
      run: |
        echo "üóëÔ∏è Uninstalling ${{ inputs.release-name }}..."
        
        DEBUG_ARG=""
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          DEBUG_ARG="--debug"
        fi
        
        DRY_RUN_ARG=""
        if [[ "${{ inputs.dry-run }}" == "true" ]]; then
          DRY_RUN_ARG="--dry-run"
        fi
        
        # Uninstall app
        if helm status ${{ inputs.release-name }} -n ${{ inputs.namespace }} &>/dev/null; then
          helm uninstall ${{ inputs.release-name }} \
            --namespace ${{ inputs.namespace }} \
            --wait \
            --timeout ${{ inputs.timeout }} \
            $DEBUG_ARG \
            $DRY_RUN_ARG
          echo "‚úÖ Application uninstalled"
        else
          echo "‚ö†Ô∏è Release ${{ inputs.release-name }} not found"
        fi

    - name: Uninstall prerequisites
      if: inputs.action == 'uninstall' && inputs.prereq-enabled == 'true'
      shell: bash
      run: |
        PREREQ_RELEASE="${{ inputs.prereq-release-name }}"
        if [[ -z "$PREREQ_RELEASE" ]]; then
          PREREQ_RELEASE="${{ inputs.release-name }}-prereqs"
        fi
        
        echo "üóëÔ∏è Uninstalling prerequisites: $PREREQ_RELEASE..."
        
        DEBUG_ARG=""
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          DEBUG_ARG="--debug"
        fi
        
        DRY_RUN_ARG=""
        if [[ "${{ inputs.dry-run }}" == "true" ]]; then
          DRY_RUN_ARG="--dry-run"
        fi
        
        if helm status "$PREREQ_RELEASE" -n ${{ inputs.namespace }} &>/dev/null; then
          helm uninstall "$PREREQ_RELEASE" \
            --namespace ${{ inputs.namespace }} \
            --wait \
            --timeout ${{ inputs.timeout }} \
            $DEBUG_ARG \
            $DRY_RUN_ARG
          echo "‚úÖ Prerequisites uninstalled"
        else
          echo "‚ö†Ô∏è Prerequisites release not found"
        fi

    # --------------------------------------------------------------------------
    # Verification
    # --------------------------------------------------------------------------
    - name: Verify deployment
      if: (inputs.action == 'install' || inputs.action == 'upgrade') && inputs.verify-install == 'true' && inputs.dry-run != 'true'
      shell: bash
      run: |
        echo "üîç Verifying deployment..."
        
        # Get all deployments in namespace
        DEPLOYMENTS=$(kubectl get deployments -n ${{ inputs.namespace }} -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
        
        for deploy in $DEPLOYMENTS; do
          echo "‚è≥ Waiting for deployment/$deploy..."
          kubectl rollout status deployment/$deploy -n ${{ inputs.namespace }} --timeout=${{ inputs.verify-timeout }} || true
        done
        
        # Get all statefulsets
        STATEFULSETS=$(kubectl get statefulsets -n ${{ inputs.namespace }} -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
        
        for sts in $STATEFULSETS; do
          echo "‚è≥ Waiting for statefulset/$sts..."
          kubectl rollout status statefulset/$sts -n ${{ inputs.namespace }} --timeout=${{ inputs.verify-timeout }} || true
        done
        
        # Get all daemonsets
        DAEMONSETS=$(kubectl get daemonsets -n ${{ inputs.namespace }} -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
        
        for ds in $DAEMONSETS; do
          echo "‚è≥ Waiting for daemonset/$ds..."
          kubectl rollout status daemonset/$ds -n ${{ inputs.namespace }} --timeout=${{ inputs.verify-timeout }} || true
        done
        
        # Verify specific resources if provided
        if [[ -n "${{ inputs.required-resources }}" ]]; then
          echo "üîç Verifying required resources..."
          IFS=',' read -ra RESOURCES <<< "${{ inputs.required-resources }}"
          for resource in "${RESOURCES[@]}"; do
            resource=$(echo "$resource" | xargs)
            echo "Checking $resource..."
            if ! kubectl get $resource -n ${{ inputs.namespace }} &>/dev/null; then
              echo "‚ùå Required resource not found: $resource"
              exit 1
            fi
            echo "‚úÖ Found: $resource"
          done
        fi
        
        echo ""
        echo "üìã Final status:"
        echo "==============="
        kubectl get all -n ${{ inputs.namespace }}
        
        echo ""
        echo "üìã Secrets:"
        kubectl get secrets -n ${{ inputs.namespace }}
        
        echo ""
        echo "üìã ConfigMaps:"
        kubectl get configmaps -n ${{ inputs.namespace }}

    # --------------------------------------------------------------------------
    # Release Info
    # --------------------------------------------------------------------------
    - name: Show release info
      if: inputs.action != 'uninstall' && inputs.dry-run != 'true'
      shell: bash
      run: |
        echo ""
        echo "üìã Release History:"
        helm history ${{ inputs.release-name }} -n ${{ inputs.namespace }} --max 5 || true
        
        echo ""
        echo "üìã Release Notes:"
        helm get notes ${{ inputs.release-name }} -n ${{ inputs.namespace }} || true

    # --------------------------------------------------------------------------
    # Slack Notification
    # --------------------------------------------------------------------------
    - name: Send Slack notification
      if: always() && inputs.slack-webhook != ''
      shell: bash
      run: |
        # Determine status
        if [[ "${{ job.status }}" == "success" ]]; then
          COLOR="good"
          EMOJI="‚úÖ"
          STATUS="Success"
        else
          COLOR="danger"
          EMOJI="‚ùå"
          STATUS="Failed"
        fi
        
        # Build message
        ACTION="${{ inputs.action }}"
        ACTION="${ACTION^}"  # Capitalize first letter
        
        PAYLOAD=$(cat <<EOF
        {
          "channel": "${{ inputs.slack-channel }}",
          "attachments": [
            {
              "color": "$COLOR",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "$EMOJI Helm $ACTION: $STATUS"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Release:*\n${{ inputs.release-name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Namespace:*\n${{ inputs.namespace }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Cluster:*\n${{ inputs.cluster-name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
                    }
                  ]
                }
              ]
            }
          ]
        }
        EOF
        )
        
        curl -s -X POST -H 'Content-type: application/json' \
          --data "$PAYLOAD" \
          "${{ inputs.slack-webhook }}" || echo "Slack notification failed"
